# Chapter 3

## 타입힌트

- 파이썬은 대표적인 동적 타이핑 언어임에도, 타입을 지정할 수 있는 타입 힌트가 PEP 484 문서에 추가됐다.  
  이 기능은 파이썬 버전 3.5 부터 사용할 수 있다.
  예:

  ```py
    a: str = "1"
    b: int = 1
  ```

  ```py
    def fn(a: int) -> bool:
        ...
  ```

  - 강제 규약이 아니다 보니, 여전히 동적으로 할당될 수 있으므로 주의가 필요하다.  
    따라서 다음과 같이 문자열에 정수를 할당하는 등의 사용 방식은 절대 지양해야 한다.

    ```
    >>> a: str = 1
    >>> type(a)
    <class 'int'>
    ```

  - 코딩 테스트는 일반적으로 짧은 알고리즘으로 끝나는 경우가 많고, 타입은 지정하지 않아도 한눈에 보일 만큼 명확하기 때문에 굳이 지정하지 않아도 문제는 없다.  
    그러나 코드를 정리할 때만이라도 타입을 모두 지정해서 보기좋게 제출한다면, 코드 리뷰 시 면접관에게 좋은 점수를 받을 수 있을 것이다.

  - 온라인 코딩 테스트 시에는 mypy를 사용하면 타입 힌트에 오류가 없는지 자동으로 확인할 수 있으므로 이를 통해 수정 후 코드를 제출할 수 있다.  
    mypy는 다음과 같이 pip로 설치할 수 있다.
    ```
    $ pip install mypy
    ```
    - 타입 힌트가 잘못 지정된 코드는 Incompatible return value type 오류가 발생한다.

## 리스트 컴프리헨션

- 파이썬은 map, filter 와 같은 함수형(Functioanl) 기능을 지원하며 다음과 같은 람다 표현식도 지원한다.
  ```
  >>> list(map(lamda x: x + 10, [1, 2, 3]))
  [11, 12, 13]
  ```
- 리스트 컴프리헨션(List Comprehension)이란 기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문으로,  
  파이썬 2.0부터 지원되었으며, 하스켈(Haskell) 같은 함수형 언어에서 기능을 차용해온 파이썬의 대표적인 특징이기도 하다.
  'Effective Python 파이썬 코딩의 기술'(길벗, 2016)에서도 1장, '파이썬다운 생각' 중 'Better way 7: map과 filter 대신 리스트 컴프리헨션을 사용하자'  
  는 절이 있을 정도로 리스트 컴프리헨션은 다방면에 유용하게 활용되며, 무엇보다 람다 표현식에 map이나 filter를 섞어서 사용하는 것에 비해 가독성이 훨씬 높다.

  다음은 홀수인 경우 2를 곱해 출력하라는 리스트 컴프리헨션이다.

  ```
  >>> [n * 2 for n in range(1, 10 + 1) if n % 2 == 1]
  [2, 6, 10, 14, 18]
  ```

  만약 리스트 컴프리헨션을 사용하지 않는다면 다음과 같이 길게 풀어서 작성해야 한다.

  ```
  >>> a = []
  >>> for n in range(1, 10 + 1):
          if n % 2 == 1:
              a.append(n * 2)
  >>> a
  [2, 6, 10, 14, 18]
  ```

  풀어서 작성한 코드는 리스트 컴프리헨션에 비해 훨씬 더 길어졌고 a라는 별도의 리스트 변수 또한 필요해졌다.  
  리스트 컴프리헨션과 비교했을 때 라인 수가 많이 증가했다.  
  물론 리스트 컴프리헨션이라고 반드시 리스트만 가능한 것은 아니다.  
  버전 2.7 이후에는 다음과 같이 리스트 외에도 딕셔너리 등이 가능하도록 추가됐다.

  ```py
  a = {}
  for key, value in original.items():
      a[key] = value
  ```

  이와 같은 정의 코드는 다음과 같이 처리할 수 있다.

  ```py
  a = {key: value for key, value in original.items()}
  ```

  이처럼 한 줄로 간결하게 작성할 수 있는 리스트 컴프리헨션은(여기서는 딕셔너리 컴프리헨션)  
  가독성이 좋은 편이지만 이 또한 무리하게 복잡하게 작성할 경우 가독성을 떨어뜨릴 수 있으므로  
  적절히 사용하는게 중요하다. 대체로 표현식은 2개를 넘지 않아야 한다.

## 제너레이터

제너레이터는 루프의 반복(Iteration) 동작을 제어할 수 있는 루틴 형태를 말한다.
예를 들어 임의의 조건으로 숫자 1억 개를 만들어내 계산하는 프로그램을 작성한다고 가정해보자.
이 경우 제너레이터가 없다면 메모리 어딘가에 만들어낸 숫자 1억 개를 보관하고 있어야 한다.
그러나 제너레이터를 이용하면, 단순히 제너레이터만 생성해두고 필요할 때 언제든 숫자를 만들어낼 수 있다.
만약에 1억 개 중 100개 정도만 쓰인다면 차이는 더욱 클 것이다.  
이때 yield 구문을 사용하면 제너레이터를 리턴할 수 있다.
기존의 함수는 return 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료한다.
그러나 yield는 제너레이터가 여기까지 실행 중이던 값을 내보낸다는(단어의 사전적 의미처럼 '양보하다') 의미로,
중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행된다.
물론 다음 코드의 경우처럼 while True 구문은 종료 조건이 없으므로 계속해서 값을 내보낼 수 있다.

```
>>> def get_natural_number():
        n = 0
        while True:
            n += 1
            yield n
```

이 경우 함수의 리턴 값은 다음과 같이 제너레이터가 된다.

```
>>> get_natural_number()
<generator object get_natural_number at 0x10d31390>
```

만약 다음 값을 생성하려면 next() 로 추출하면 된다.
예를 들어 100개의 값을 생성하고 싶다면 다음과 같이 100번 동안 next()를 수행하면 된다.

```
>>> g = get_natural_number()
>>> for _ in range(0, 100):
        print(next(g))

1
2
3
...
98
99
100
```

아울러 제너레이터는 다음과 같이 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능하다.

```
>>> def generator():
       yield 1
       yield 'string'
       yield True
>>> g = generator()
>>> g
<generator object generator at 0x10a47c678>
>>> next(g)
1
>>> next(g)
'string'
>>> next(g)
True
```

## range

제너레이터의 방식을 활용하는 대표적인 함수로 range()가 있다. 주로 for 문에서 쓰이는 range() 함수의 쓰임은 다음과 같다.

```
>>> list(range(5))
[0, 1, 2, 3, 4]
>>> range(5)
range(0, 5)
>>> type(range(5))
<class 'range'>
>>> for i in range(5):
        print(i, end=' ')

0 1 2 3 4
```

이 코드에서 range()는 range 클래스를 리턴하며,
for 문에서 사용할 경우 내부적으로는 제너레이터의 next()를 호출하듯
매번 다음 숫자를 생성해내게 된다.
... (중략) -> 중략부분에서 파이썬 2에 대한 이야기가 나오는데 실제로 vs code 에서 파이썬을 실행해서 터미널에서 해보면 python 2.7 버전이 작동 되어 python3 와 다르게 나온다.
만약 생성할 숫자가 100만 개쯤 된다면 어떻게 될까?
메모리에서 적지 않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것이다.
그러나 제너레이터를 리턴하듯 range 클래스만 리턴하면 그렇지 않다.
생성 조건만 정해두고 나중에 필요할 때 생성해서 꺼내 쓸 수 있다.
다음은 숫자 100만 개를 생성하는 2가지 방법이다.
